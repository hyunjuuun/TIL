# 11.컬렉션 프레임웍

#TIL/java/자바의정석

---

## 컬렉션 프레임웍의 핵심 인터페이스

- Collection
  - List
  - Set
- Map

**컬렉션 프레임웍의 핵심 인터페이스간의 상속 계층도**

<br>

인터페이스 List와 Set을 구현한 Collection class들은 서로 많은 공통부분이 존재하므로 공통된 부분을 뽑아 Collection 인터페이스로 정의,

Map 인터페이스는 List, Set과는 전혀 다른 형태로 컬렉션을 다루기 때문에 상속 계층도에 포함되지 않았다.  

<br>

| 인터페이스       | 특징                                                         |
| ---------------- | ------------------------------------------------------------ |
| `List`           | 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.         |
| List 구현 클래스 | ArrayList, LinkedList, Stack, Vector 등                      |
| `Set`            | 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다. |
| Set 구현 클래스  | HashSet, TreeSet 등                                          |
| `Map`            | 키(key)와 값(value)의 쌍(pair)로 이루어진 데이터의 집합.<br>순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.<br>예) 우편번호, 지역번호 |
| Map 구현 클래스  | HashMap, TreeMap, Hashtable, Properties 등                   |

<br>

Vector,Stack,Hashtable,Properties 등의 클래스는 컬렉션 프레임웍이 만들어지기 이전부터 존재했다.

Vector, Hashtable (가급적 사용 X) / ArrayList, HashMap 사용

<br>

### Collection 인터페이스

: List와 Set의 조상 인터페이스

<br>

<center>Collection 인터페이스에 정의된 메서드</center>

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean add(Object o)<br>boolean addAll(Collection c)        | 지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에 추가한다. |
| void clear()                                                 | Collection의 모든 객체를 삭제한다.                           |
| boolean contains(Object o)<br>boolean containsAll(Collection c) | 지정된 객체(o) 또는 Collection(c)의 객체들이 Collection에 포함되어 있는지 확인한다. |
| boolean equals(Object o)                                     | 동일한 Collection인지 비교한다.                              |
| int hashCode()                                               | Collection의 hash code를 반환한다.                           |
| boolean isEmpty()                                            | Collection이 비어있는지 확인한다.                            |
| Iterator iterator()                                          | Collection의 Iterator를 얻어서 반환한다.                     |
| boolean remove(Object o)                                     | 지정된 객체를 삭제한다.                                      |
| boolean removeAll(Collection c)                              | 지정된 Collection에 포함된 객체들을 삭제한다.                |
| boolean retainAll(Collection c)                              | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다.<br>이 작업으로 인해 Collection에 변화가 있으면 true를 그렇지 않으면 false를 반환한다. |
| int size()                                                   | Collection에 저장된 객체의 개수를 반환한다.                  |
| Object[] toArray()                                           | Collection에 저장된 객체를 객체배열(Object[])로 반환한다.    |
| Object[] toArray(Object[] a)                                 | 지정된 배열에 Collection의 객체를 저장해서 반환한다.         |

> Iterator 인터페이스는 컬렉션에 포함된 객체들에 접근할 수 있는 방법을 제공한다.

<br>

### List 인터페이스

: 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는 데 사용

<br>

**List의 상속계층도**

- List
  - Vector
    - Stack
  - ArrayList
  - LinkedList

<br>

<center>List 인터페이스의 메서드</center>

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| void add(int index, Object element)<br>boolean addAll(int index, Collection c) | 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가한다. |
| Object get(int index)                                        | 지정된 위치(index)에 있는 객체를 반환한다.                   |
| int indexOf(Object c)                                        | 지정된 객체의 위치(index)를 반환한다.<br>(List의 첫 번째 요소부터 조회) |
| int lastIndexOf(Object c)                                    | 지정된 객체의 위치(index)를 반환한다.<br>(List의 마지막 요소부터 조회) |
| ListIteraotr listIterator()<br>ListIteraotr listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다.        |
| Object remove(int index)                                     | 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환한다. |
| Object set(int index, Object element)                        | 지정된 위치(index)에 객체(element)를 저장한다.               |
| void sort(Comparator c)                                      | 지정된 비교자(comparator)로 List를 정렬한다.                 |
| List subList(int fromIndex, int toIndex)                     | 지정된 범위(fromIndex부터 toIndex)에 있는 객체를 반환한다.   |

<br>

### Set 인터페이스

: 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는 데 사용

<br>

**Set의 상속계층도**

- Set
  - HashSet
  - SortedSet
    - TreeSet

<br>

### Map 인터페이스

: 키(key)와 값(value)을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용

키는 중복 X, 값은 중복 가능

<br>

**Map의 상속계층도**

- Map
  - Hashtable
  - HashMap
    - LinkedHashMap
  - SortedMap
    - TreeMap

<br>

<center>Map 인터페이스의 메서드</center>

| 메서드                               | 설명                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| void clear()                         | Map의 모든 객체를 삭제한다.                                  |
| boolean containsKey(Object key)      | 지정된 key 객체와 일치하는 Map의 key 객체가 있는지 확인한다. |
| boolean containsValue(Object value)  | 지정된 value 객체와 일치하는 Map의 value 객체가 있는지 확인한다. |
| Set entrySet()                       | Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set을 반환한다. |
| boolean equals(Object o)             | 동일한 Map인지 비교한다.                                     |
| Object get(Object key)               | 지정한 key 객체에 대응하는 value 객체를 찾아서 반환한다.     |
| int hashCode()                       | 해시코드를 반환한다.                                         |
| Set keySet()                         | Map에 저장된 모든 key객체를 반환한다.                        |
| Object put(Object key, Object value) | Map에 value객체를 key객체에 연결(mapping)하여 저장한다.      |
| void putAll(Map t)                   | 지정된 Map의 모든 key-value 쌍을 추가한다.                   |
| Object remove(Object key)            | 지정한 key객체와 일치하는 key-value 객체를 삭제한다.         |
| int size()                           | Map에 저장된 key-value 쌍의 개수를 반환한다.                 |
| Collection values()                  | Map에 저장된 모든 value 객체를 반환한다.                     |

<br>

values()의 반환타입은 Collection, keySet()의 반환타입은 Set인 이유가 무엇일까?

Map 인터페이스에서는 값은 중복을 허용하므로 Collection 타입으로, 키는 중복을 허용하지 않으므로 Set 타입으로 반환한다.

<br>

### Map.Entry 인터페이스

: Map 인터페이스의 내부 인터페이스

Map에 저장되는 key-value 쌍을 다루기 위해서 Map 인터페이스 내부적으로 Entry 인터페이스를 정의해놓았다.

<br>

<center>Map.Entry 인터페이스의 메서드</center>

| 메서드                        | 설명                                      |
| ----------------------------- | ----------------------------------------- |
| boolean equals(Object o)      | 동일한 Entry인지 비교한다.                |
| Object getKey()               | Entry의 key객체를 반환한다.               |
| Object getValue()             | Entry의 value객체를 반환한다.             |
| int hashCode()                | Entry의 해시코드를 반환한다.              |
| Object setValue(Object value) | Entry의 value객체를 지정된 객체로 바꾼다. |

<br>

---

## ArrayList

- List 인터페이스를 구현하므로 데이터의 저장순서가 유지되고 중복을 허용한다.

- 기존의 Vector를 개선 (구현원리와 기능적인 측면에서 동일)

<br>

Object 배열을 이용해서 데이터를 순차적으로 저장한다.

배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성하고 기존 배열의 데이터를 새로 만든 배열로 복사한다.

<br>

(ArrayList의 생성자와 메서드는 책 585p 참고)

<br>

ArrayList를 생성할 때는 저장할 요소의 개수를 고려해서 실제 저장할 개수보다 약간 여유있는 크기로 하는 것이 좋다.

지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만 이 과정에서 처리시간이 많이 소요되기 때문이다.

<br>

ArrayList나 Vector 같이 배열을 이용한 자료구조

- 데이터를 읽어오고 저장하는 데는 효율이 좋다.
- 용량 변경이 필요할 때는 효율이 떨어진다.
  - 따라서 처음 인스턴스를 생성할 때, 저장할 데이터의 개수를 고려하여 충분한 용량의 인스턴스를 생성하는 것이 좋다.

<br>

## LinkedList

배열은 데이터를 조회하는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점을 가진다.

1. 크기를 변경할 수 없다.
   - 크기 변경이 불가능하므로 새로운 배열을 생성해서 데이터를 복사해야한다.
   - 실행속도 향상을 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.
2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.
   - 차례대로 데이터를 추가하고 마지막부터 데이터를 삭제하는 것은 빠르지만 배열의 중간에 데이털를 추가하려면, 다른 데이터를 복사하여 이동시켜야 한다.

<br>

이러한 단점을 보완하기 위해서 `링크드 리스트`(linked list)라는 자료구조가 고안되었다.

링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.

<br>

```java
class Node {
  Node next; // 다음 요소의 주소를 저장
  Object obj; // 데이터를 저장
}
```

<br>

링크드 리스트는 이동방향이 단방향이다.

- 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어렵다.

<br>

이 점을 보완한 것이 `더블 링크드 리스트`(이중 연결리스트, doubly linked list)이다.

- 참조변수를 하나 더 추가하여 다음 요소에 대한 참조뿐 아니라 이전 요소에 대한 참조가 가능

<br>

```java
class Node {
	Node next; // 다음 요소의 주소를 저장
	Node previous; // 이전 요소의 주소를 저장
	Object obj; // 데이터를 저장
}
```

<br>

더블 링크드 리스트의 접근성을 보다 향상시킨 것이 `더블 써큘러 링크드 리스트`(이중 원형 연결리스트, doubly circular linked list)이다.

- 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.
- 마지막 다음은 처음, 처음 이전은 마지막

<br>

(LinkedList의 생성자와 메서드는 책 599p 참고)

<br>

### ArrayList와 LinkedList 비교

- 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다.

- 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.

<br>

배열의 각 요소들은 메모리상에 연속적으로 존재하므로 원하는 요소의 주소를 얻어서 저장된 데이터를 곧바로 읽어올 수 있지만, LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이므로 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있다.

따라서 LinkedList는 저장 데이터의 개수가 많아질수록 데이터를 읽어 오는 시간이 길어진다는 단점이 있다.

<br>

|   컬렉션   | 읽기(접근시간) | 추가/삭제 |                          비고                          |
| :--------: | :------------: | :-------: | :----------------------------------------------------: |
| ArrayList  |     빠르다     |  느리다   | 순차적인 추가, 삭제는 더 빠름<br>비효율적인 메모리사용 |
| LinkedList |     느리다     |  빠르다   |           데이터가 많을수록 접근성이 떨어짐            |

<br>

## Stack과 Queue

### Stack

- 마지막에 저장한 데이터를 가장 먼저 꺼내는 LIFO(Last In First Out)구조
- ArrayList로 구현하는 것이 적합 (순차적인 데이터 추가, 삭제)

<br>

### Queue

- 처음에 저장한 데이터를 가장 먼저 꺼내는 FIFO(First In First Out)구조
- LinkedList로 구현하는 것이 적합 (항상 첫 번째 저장된 데이터를 삭제)

<br>

(Stack과 Queue의 메서드는 책 604p 참고)

<br>

### 스택과 큐의 활용

**스택의 활용 예**

: 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로

**큐의 활용 예**

: 최근 사용 문서, 인쇄작업 대기목록, 버퍼(buffer)









