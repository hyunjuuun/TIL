# 변수 선언


var, let, const

### var 키워드의 단점

여러 단점 중 가장 대표적인 것은 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 한다.

ES6에서 let과 const를 도입한 이유가 var 키워드의 여러 단점을 보완하기 위함이다.

(추후 학습)

자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.

1. 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.

```jsx
var score; // 변수 선언(변수 선언문)
```

2. 초기화 단계: 값을 저장히기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

(변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 23장에서 학습)

var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다. 따라서 var 키워드로 선언한 변수는 어떠한 값을 할당하지 않더라도 undefined라는 값을 가진다.

초기화 단계를 거치지 않으면 변수 선언 시 확보된 메모리 공간에 이전에 다른 애플리케이션에서 사용했던 값이 남아 있을 수 있다. (쓰레기 값, garbage value)

자바스크립트의 var 키워드는 암묵적인 초기화를 수행하므로 이러한 위험으로부터 안전하다.

# 변수 선언의 실행 시점과 변수 호이스팅


```jsx
console.log(score); // undefined

var score; // 변수 선언문
```

자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 참조 에러(Reference Error)가 발생할 것처럼 보이지만 undefined가 출력된다.

**그 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**

이처럼 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)**이라 한다.

(모든 선언문이 런타임 이전 단계에서 먼저 실행된다)

# 식별자 네이밍 규칙


```jsx
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고,

생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.
